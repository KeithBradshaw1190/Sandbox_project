import { __assign } from "tslib";
import { addEventListener, DOM_EVENT, generateUUID, monitor, noop, ONE_MINUTE, throttle } from '@datadog/browser-core';
import { supportPerformanceTimingEvent } from '../../../browser/performanceCollection';
import { LifeCycleEventType } from '../../lifeCycle';
import { trackEventCounts } from '../../trackEventCounts';
import { waitIdlePageActivity } from '../../trackPageActivities';
import { ViewLoadingType } from '../../../rawRumEvent.types';
import { trackTimings } from './trackTimings';
export var THROTTLE_VIEW_UPDATE_PERIOD = 3000;
export var SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE;
export function trackViews(location, lifeCycle, onNewLocation) {
    var _a;
    if (onNewLocation === void 0) { onNewLocation = function () { return undefined; }; }
    onNewLocation = wrapOnNewLocation(onNewLocation);
    var startOrigin = 0;
    var initialView = newView(lifeCycle, location, ViewLoadingType.INITIAL_LOAD, document.referrer, startOrigin, (_a = onNewLocation(location)) === null || _a === void 0 ? void 0 : _a.viewName);
    var currentView = initialView;
    var stopTimingsTracking = trackTimings(lifeCycle, function (timings) {
        initialView.updateTimings(timings);
        initialView.scheduleUpdate();
    }).stop;
    var stopHistoryTracking = trackHistory(onLocationChange).stop;
    var stopHashTracking = trackHash(onLocationChange).stop;
    function onLocationChange() {
        var _a = onNewLocation(location, currentView.getLocation()) || {}, viewName = _a.viewName, shouldCreateView = _a.shouldCreateView;
        if (shouldCreateView || (shouldCreateView === undefined && currentView.isDifferentView(location))) {
            // Renew view on location changes
            currentView.end();
            currentView.triggerUpdate();
            currentView = newView(lifeCycle, location, ViewLoadingType.ROUTE_CHANGE, currentView.url, undefined, viewName);
            return;
        }
        currentView.updateLocation(location);
        currentView.triggerUpdate();
    }
    // Renew view on session renewal
    lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, function () {
        // do not trigger view update to avoid wrong data
        currentView.end();
        currentView = newView(lifeCycle, location, ViewLoadingType.ROUTE_CHANGE, currentView.url);
    });
    // End the current view on page unload
    lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, function () {
        currentView.end();
        currentView.triggerUpdate();
    });
    // Session keep alive
    var keepAliveInterval = window.setInterval(monitor(function () {
        currentView.triggerUpdate();
    }), SESSION_KEEP_ALIVE_INTERVAL);
    return {
        addTiming: function (name, time) {
            if (time === void 0) { time = performance.now(); }
            currentView.addTiming(name, time);
            currentView.triggerUpdate();
        },
        stop: function () {
            stopHistoryTracking();
            stopHashTracking();
            stopTimingsTracking();
            currentView.end();
            clearInterval(keepAliveInterval);
        },
    };
}
function newView(lifeCycle, initialLocation, loadingType, referrer, startTime, name) {
    if (startTime === void 0) { startTime = performance.now(); }
    // Setup initial values
    var id = generateUUID();
    var eventCounts = {
        errorCount: 0,
        longTaskCount: 0,
        resourceCount: 0,
        userActionCount: 0,
    };
    var timings = {};
    var customTimings = {};
    var documentVersion = 0;
    var cumulativeLayoutShift;
    var loadingTime;
    var endTime;
    var location = __assign({}, initialLocation);
    lifeCycle.notify(LifeCycleEventType.VIEW_CREATED, { id: id, startTime: startTime, location: location, referrer: referrer });
    // Update the view every time the measures are changing
    var _a = throttle(monitor(triggerViewUpdate), THROTTLE_VIEW_UPDATE_PERIOD, {
        leading: false,
    }), scheduleViewUpdate = _a.throttled, cancelScheduleViewUpdate = _a.cancel;
    var stopEventCountsTracking = trackEventCounts(lifeCycle, function (newEventCounts) {
        eventCounts = newEventCounts;
        scheduleViewUpdate();
    }).stop;
    var _b = trackLoadingTime(loadingType, function (newLoadingTime) {
        loadingTime = newLoadingTime;
        scheduleViewUpdate();
    }), setActivityLoadingTime = _b.setActivityLoadingTime, setLoadEvent = _b.setLoadEvent;
    var stopActivityLoadingTimeTracking = trackActivityLoadingTime(lifeCycle, setActivityLoadingTime).stop;
    var stopCLSTracking;
    if (isLayoutShiftSupported()) {
        cumulativeLayoutShift = 0;
        (stopCLSTracking = trackLayoutShift(lifeCycle, function (layoutShift) {
            cumulativeLayoutShift += layoutShift;
            scheduleViewUpdate();
        }).stop);
    }
    else {
        stopCLSTracking = noop;
    }
    // Initial view update
    triggerViewUpdate();
    function triggerViewUpdate() {
        documentVersion += 1;
        lifeCycle.notify(LifeCycleEventType.VIEW_UPDATED, {
            cumulativeLayoutShift: cumulativeLayoutShift,
            customTimings: customTimings,
            documentVersion: documentVersion,
            eventCounts: eventCounts,
            id: id,
            name: name,
            loadingTime: loadingTime,
            loadingType: loadingType,
            location: location,
            referrer: referrer,
            startTime: startTime,
            timings: timings,
            duration: (endTime === undefined ? performance.now() : endTime) - startTime,
            isActive: endTime === undefined,
        });
    }
    return {
        scheduleUpdate: scheduleViewUpdate,
        end: function () {
            endTime = performance.now();
            stopEventCountsTracking();
            stopActivityLoadingTimeTracking();
            stopCLSTracking();
            lifeCycle.notify(LifeCycleEventType.VIEW_ENDED);
        },
        isDifferentView: function (otherLocation) {
            return (location.pathname !== otherLocation.pathname ||
                (!isHashAnAnchor(otherLocation.hash) && otherLocation.hash !== location.hash));
        },
        getLocation: function () {
            return location;
        },
        triggerUpdate: function () {
            // cancel any pending view updates execution
            cancelScheduleViewUpdate();
            triggerViewUpdate();
        },
        updateTimings: function (newTimings) {
            timings = newTimings;
            if (newTimings.loadEvent !== undefined) {
                setLoadEvent(newTimings.loadEvent);
            }
        },
        addTiming: function (name, time) {
            customTimings[sanitizeTiming(name)] = time - startTime;
        },
        updateLocation: function (newLocation) {
            location = __assign({}, newLocation);
        },
        get url() {
            return location.href;
        },
    };
}
function isHashAnAnchor(hash) {
    var correspondingId = hash.substr(1);
    return !!document.getElementById(correspondingId);
}
function trackHistory(onHistoryChange) {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    var originalPushState = history.pushState;
    history.pushState = monitor(function () {
        originalPushState.apply(this, arguments);
        onHistoryChange();
    });
    // eslint-disable-next-line @typescript-eslint/unbound-method
    var originalReplaceState = history.replaceState;
    history.replaceState = monitor(function () {
        originalReplaceState.apply(this, arguments);
        onHistoryChange();
    });
    var removeListener = addEventListener(window, DOM_EVENT.POP_STATE, onHistoryChange).stop;
    var stop = function () {
        removeListener();
        history.pushState = originalPushState;
        history.replaceState = originalReplaceState;
    };
    return { stop: stop };
}
function trackHash(onHashChange) {
    return addEventListener(window, DOM_EVENT.HASH_CHANGE, onHashChange);
}
function trackLoadingTime(loadType, callback) {
    var isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD;
    var isWaitingForActivityLoadingTime = true;
    var loadingTimeCandidates = [];
    function invokeCallbackIfAllCandidatesAreReceived() {
        if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {
            callback(Math.max.apply(Math, loadingTimeCandidates));
        }
    }
    return {
        setLoadEvent: function (loadEvent) {
            if (isWaitingForLoadEvent) {
                isWaitingForLoadEvent = false;
                loadingTimeCandidates.push(loadEvent);
                invokeCallbackIfAllCandidatesAreReceived();
            }
        },
        setActivityLoadingTime: function (activityLoadingTime) {
            if (isWaitingForActivityLoadingTime) {
                isWaitingForActivityLoadingTime = false;
                if (activityLoadingTime !== undefined) {
                    loadingTimeCandidates.push(activityLoadingTime);
                }
                invokeCallbackIfAllCandidatesAreReceived();
            }
        },
    };
}
function trackActivityLoadingTime(lifeCycle, callback) {
    var startTime = performance.now();
    var stopWaitIdlePageActivity = waitIdlePageActivity(lifeCycle, function (hadActivity, endTime) {
        if (hadActivity) {
            callback(endTime - startTime);
        }
        else {
            callback(undefined);
        }
    }).stop;
    return { stop: stopWaitIdlePageActivity };
}
/**
 * Track layout shifts (LS) occuring during the Views.  This yields multiple values that can be
 * added up to compute the cumulated layout shift (CLS).
 *
 * See isLayoutShiftSupported to check for browser support.
 *
 * Documentation: https://web.dev/cls/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts
 */
function trackLayoutShift(lifeCycle, callback) {
    var stop = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {
            callback(entry.value);
        }
    }).unsubscribe;
    return {
        stop: stop,
    };
}
/**
 * Check whether `layout-shift` is supported by the browser.
 */
function isLayoutShiftSupported() {
    return supportPerformanceTimingEvent('layout-shift');
}
/**
 * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $
 */
function sanitizeTiming(name) {
    var sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_');
    if (sanitized !== name) {
        console.warn("Invalid timing name: " + name + ", sanitized to: " + sanitized);
    }
    return sanitized;
}
function wrapOnNewLocation(onNewLocation) {
    return function (newLocation, oldLocation) {
        var result;
        try {
            result = onNewLocation(newLocation, oldLocation);
        }
        catch (err) {
            console.error('onNewLocation threw an error:', err);
        }
        return result;
    };
}
//# sourceMappingURL=trackViews.js.map